<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore.js"></script>
    <script src='https://cdn.rawgit.com/nicgirault/circosJS/v2/dist/circos.js'></script>
  </head>

  <body>
    <div id="circos"></div>
    <script>
      async function readJsonData() {
        const gene = await d3.json('http://localhost:3000/data/gene.json')
        const fusionData = await d3.json('http://localhost:3000/data/fusion.json')
        // console.log('fusion', fusionData)
        // forEach 의 return value 는 undefined, 
        // map 은 콜백 함수의 결과 값들로 구성된 새로운 배열을 return

        fusionData.map((d) => {
          d['source_id'] = d.leftBreakPoint.split(':')[0];
          d['source_name'] = d.fusionName.split('--')[0];
          d['target_id'] = d.rightBreakpoint.split(':')[0];
          d['target_name'] = d.fusionName.split('--')[1];

          for(let g = 0; g < gene.length; g++) {
            if(d.source_name === gene[g].label) {
              d['source_breakpoint'] = gene[g].len / 2
              d['size'] = gene[g].len
            }
            if(d.target_name === gene[g].label) {
              d['target_breakpoint'] = gene[g].len / 2
            }
          }
          return fusionData;
        });
        
        const fusion = [];
        fusionData.forEach((d) => {
          if(d.junctionReadCount > 0 && d.spanningFragCount > 0) {
            fusion.push(d);
          }
        });
        return { 
          gene, 
          fusion,
          fusionData
        };
      }
      readJsonData().then(async(d)=> {
        const { gene, fusion, fusionData } = d;
        // console.log('data', d)

        // sorting gene
        gene.map((d) => {
          d["num"] = d.chr.substr(3, 2);
          if(d.num === 'X') {
            d.num = Number(d.chr.substr(3, 2));
            d.num = 23;
          }
          if(d.num === 'Y') {
            d.num = Number(d.chr.substr(3, 2));
            d.num = 24
          }
        });
        gene.sort(function(a, b) {
          return a.num - b.num
        });

        // draw circos chart
        const drawCircos = (gene, d) => {
          const width = 800;
          // create circos instance
          const circos = new Circos({
            container: '#circos',
            width: width,
            height: width
          });
          // format fusion data
          d = d.map(function (d) {
            return {
              source: {
                id: d.source_name,
                start: parseInt(d.source_breakpoint) - parseInt(d.source_breakpoint),
                end: parseInt(d.source_breakpoint) + parseInt(d.source_breakpoint),
                name: d.source_name,
                chr: d.source_id
              },
              target: {
                id: d.target_name,
                start: parseInt(d.target_breakpoint) - parseInt(d.target_breakpoint),
                end: parseInt(d.target_breakpoint) + parseInt(d.target_breakpoint),
                name: d.target_name,
                chr: d.target_id
              }
            }
          });

          // config circos layout
          circos
            .layout(gene,
            {
              innerRadius: width/2 - 100,
              outerRadius: width/2 - 90,
              labels: {
                display: false,
                size: 10,
                color: '#181818',
                radialOffset: 40
              },
              ticks: {
                display: false,
                color: '#181818',
                labelSize: 10
              }
            })
            .chords('l1', d,
            {
              opacity: 0.5,
              color: '#ff5722',
              tooltipContent: function (d) {
                return '<h3>' + d.source.id + ' ➤ ' + d.target.id + '</h3>'
              },
            })
            .render()
          // end circos object
        }
        // Call drawCircos
        drawCircos(gene, fusion);

        // New layout for transfer label location
        const width = 800;
        const arcLabel = (() => {
          const radius = Math.min(width, width) / 2 * 0.9;
          return d3.arc().innerRadius(radius).outerRadius(radius);
        })();
           
        const layout = d3.select('.cs-layout').selectAll('g').data(gene).join('g')
          .attr('class', d => d.label)
          .attr('opacity', '1')

        const makeAngle = (d) => {
          // console.log('makeAngle', d)
          const k = ((d.end - d.start) / 2) / d.len ;
          const angle = d.len * k + d.start;
          // console.log(k)
          // console.log('angle', angle)
          return angle
        }
        
        const text = layout.append('text')
          .attr('transform', d => makeAngle(d) > Math.PI ? `rotate(${makeAngle(d) * 180 / Math.PI - 90}) translate(330, 0)` : `rotate(${makeAngle(d) * 180 / Math.PI - 90}) translate(330, 0)`)
          .text(d => d.label)
          .style('font-size', '11px')
          .attr('dy', '.35em')
        // end circos
      })

    </script>
  </body>
</html>