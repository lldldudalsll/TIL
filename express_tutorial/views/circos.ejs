<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/d3-queue.v3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.9.1/underscore.js"></script>
    <script src='https://cdn.rawgit.com/nicgirault/circosJS/v2/dist/circos.js'></script>
  </head>

  <body>
    <div id="chordChart"></div>
    <script>
      async function readJsonData() {
        const geneData = await d3.json('http://localhost:3000/data/gene.json')
        const fusionData = await d3.json('http://localhost:3000/data/fusion.json')
        // console.log('fusion', fusionData)
        // forEach 의 return value 는 undefined, 
        // map 은 콜백 함수의 결과 값들로 구성된 새로운 배열을 return

        fusionData.map((d) => {
          d['source_id'] = d.leftBreakPoint.split(':')[0];
          d['source_name'] = d.fusionName.split('--')[0];
          d['target_id'] = d.rightBreakpoint.split(':')[0];
          d['target_name'] = d.fusionName.split('--')[1];

          for(let g = 0; g < geneData.length; g++) {
            if(d.source_name === geneData[g].label) {
              d['source_breakpoint'] = geneData[g].len / 2
            }
            if(d.target_name === geneData[g].label) {
              d['target_breakpoint'] = geneData[g].len / 2
            }
          }
          return fusionData;
        });
        
        const fusion = [];
        fusionData.forEach((d) => {
          if(d.junctionReadCount > 0 && d.spanningFragCount > 0) {
            fusion.push(d);
          }
        });
        return fusion;
      }
      readJsonData().then(async(d)=> {
        const gene = await d3.json('http://localhost:3000/data/gene.json')

        // sorting gene
        gene.map((d) => {
          d["num"] = d.chr.substr(3, 2);
          if(d.num !== ('X' || 'Y')) {
            d.num = Number(d.chr.substr(3, 2));
          }
          if(d.num === 'X') {
            d.num = 23
          }
          if(d.num === 'Y') {
            d.num = 24
          }
        });
        gene.sort(function(a, b) {
          return a.num - b.num
        });

        // draw circos chart
        const drawCircos = (gene, d) => {
          const width = 800;
          // create circos instance
          const circos = new Circos({
            container: '#chordChart',
            width: width,
            height: width
          });

          // format fusion data
          d = d.map(function (d) {
            return {
              source: {
                id: d.source_name,
                start: parseInt(d.source_breakpoint) - 10000,
                end: parseInt(d.source_breakpoint) + 10000,
                name: d.source_name
              },
              target: {
                id: d.target_name,
                start: parseInt(d.target_breakpoint) - 10000,
                end: parseInt(d.target_breakpoint) + 10000,
                name: d.target_name
              }
            }
          })
          // config circos layout
          circos
            .layout(gene,
            {
              innerRadius: width/2 - 100,
              outerRadius: width/2 - 90,
              // gap: 0.06,
              // cornerRadius: 5,
              labels: {
                display: true,
                size: 8,
                color: '#181818',
                radialOffset: 90,
              },
              ticks: {
                display: true,
                color: '#181818',
                labelSize: 10
              }
            })
            .chords('l1', d,
            {
              radius: function (d) {
                if (d.source_name === 'ABL2') {
                  return 0.5
                } else {
                  return null
                }
              },
              opacity: 0.7,
              color: '#ff5722',
              tooltipContent: function (d) {
                return '<h3>' + d.source.id + ' ➤ ' + d.target.id + '</h3>'
              },
            })
            .render()
        }
        drawCircos(gene, d);
        // d3.queue()
        //   .defer(d3.json, 'http://localhost:3000/data/gene.json')
        //   .defer(d3.json, 'http://localhost:3000/data/gene.json')
        //   .await(drawCircos)
      });
    </script>
  </body>
</html>