<html>

<head>
  <title><%= title %></title>
  <link rel="stylesheet" type="text/css" href="css/style.css">
  <script src="https://d3js.org/d3.v5.min.js"></script>
</head>

<body>
  <div id="circos"></div>
  <script>
    async function readJsonData() {
      const data = [];
      const receiveGene = await d3.json('http://localhost:3000/data/gene.json')
        .then((d) => {
          const angle = new Array;
          const sortStr = new Array;
          for (let i = 0; i < d.length; i++) {
            angle.push(Number(d[i].end) - Number(d[i].start));
            d[i]["size"] = angle[i];

            sortStr.push(d[i].reference.substr(3, 2));
            d[i]["chr"] = sortStr[i];

            const object = {
              source: {
                name: "",
                size: 0,
                chr: ""
              },
              target: {
                name: ""
              }
            };
            
            object.source.name = d[i].geneName;
            object.source.size = d[i].size;
            object.source.chr = d[i].chr;
            data.push(object);
          };
          data.sort(function(a, b) {
            return a.chr - b.chr;
          });
          return data;
        })
        .then(async(data) => {
          const fusion = await d3.json('http://localhost:3000/data/fusion.json')

          // forEach 의 return value 는 undefined, 
          // map 은 콜백 함수의 결과 값들로 구성된 새로운 배열을 return
          
          const duplicate = [];
          fusion.forEach((d) => {
            if(d.junctionReadCount > 1 && d.spanningFragCount > 1) {
              duplicate.push(d.fusionName.split('--'));
            }
          })
          // console.log('duplicate', duplicate);
          data.map((d) => {
            for (let i = 0; i < duplicate.length; i++) {
              if(d.source.name === duplicate[i][0]) {
                d.target.name = duplicate[i][1]
              }
            }
          });
          // console.log('fusion data', fusion);
        });

      return data;
    }
    readJsonData().then((data)=> {
      const svg = d3.select('body').text('aaasdssdsdsd');
      console.log('D3 data', data);
    })


    // let geneRequest = new Request('http://localhost:3000/data/gene.json', {
    //     method: 'GET'
    // });

    // const gene = [];
    // fetch(geneRequest).then((response) => {
    //   response.json().then((data) => {
    //     const angle = new Array;
    //     const sortStr = new Array;

    //     for (let i = 0; i < data.length; i++) {
    //       angle.push(Number(data[i].end) - Number(data[i].start));
    //       data[i]["size"] = angle[i];

    //       sortStr.push(data[i].reference.substr(3, 2));
    //       data[i]["chr"] = sortStr[i];
    //       gene.push(data[i]);
    //     }
    //     gene.sort(function (a, b) {
    //       return a.chr - b.chr
    //     });
    //   });
    // });
    // console.log('gene data', gene)

    // let fusionRequest = new Request('http://localhost:3000/data/fusion.json', {
    //     method: 'GET'
    // });

    // const fusion = [];
    // fetch(fusionRequest).then((response) => {
    //     response.json().then((data) => {
    //         for (let i = 0; i < data.length; i++) {
    //             fusion.push(data[i]);
    //         }
    //         data.forEach(d => {
    //             if (d.junctionReadCount > 1 && d.spanningFragCount > 1) {
    //                 console.log(d.fusionName)
    //             }
    //         });
    //         fusion.slice()
    //     });
    // });
  </script>
</body>

</html>