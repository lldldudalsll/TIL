<!DOCTYPE html>
<html>
  <head>
    <title><%= title %></title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="js/circos.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src='https://cdn.rawgit.com/nicgirault/circosJS/v2/dist/circos.js'></script>
    <!-- <script src="https://cdn.jsdelivr.net/npm/nightmare@3.0.2/lib/nightmare.min.js"></script> -->
  </head>

  <body>
    <div id="circos"></div>
    <script>
      
      async function readJsonData() {
        const gene = await d3.json('http://localhost:3000/data/gene.json')
        const fusionData = await d3.json('http://localhost:3000/data/fusion.json')
        // console.log('fusion', fusionData)
        // forEach 의 return value 는 undefined, 
        // map 은 콜백 함수의 결과 값들로 구성된 새로운 배열을 return

        // const others = new Object
        function Other(label, id, strand) {
          this.label = label,
          this.id = id,
          this.chr = 'chrOthers',
          this.strand = strand,
          this.len = 350000
        }

        fusionData.map((d) => {
          d['source_id'] = d.leftBreakPoint.split(':')[0];
          d['source_name'] = d.fusionName.split('--')[0];
          d['source_strand'] = d.leftBreakPoint.split(':')[2];
          d['target_id'] = d.rightBreakpoint.split(':')[0];
          d['target_name'] = d.fusionName.split('--')[1];
          d['target_strand'] = d.rightBreakpoint.split(':')[2];

          // for(let g = 0; g < gene.length; g++) {
          //   if(d.source_name === gene[g].label) {
          //     d['source_breakpoint'] = gene[g].len / 2
          //     d['size'] = gene[g].len
          //   }
          //   if(d.target_name === gene[g].label) {
          //     d['target_breakpoint'] = gene[g].len / 2
          //   }
          // }
          return fusionData;
        });
        
        const fusion = [];
        fusionData.forEach((d) => {
          if( d.prot_fusion_type === 'INFRAME' && (d.junctionReadCount > 0 && d.spanningFragCount > 0)) {
            fusion.push(d);
          }
        });
        // console.log(gene)
        
        fusion.forEach((d) => {
          const source = gene.find(item => item.label === d.source_name)
          // console.log('aaa', a)
          const target = gene.find(item => item.label === d.target_name)
          // console.log('bbb', b)
          // !a || (a && a.length === 0)
          if(!source) {
            // console.log('d.sourcename', d.source_name)
            gene.push(new Other(d.source_name, d.source_name, d.source_strand))
          } 
          if(!target) {
            // console.log(d.target_name)
            gene.push(new Other(d.target_name, d.target_name, d.target_strand))
          } 
        })

        return { 
          gene, 
          fusion
        };
      }
      readJsonData().then(async(d)=> {
        const { gene, fusion } = d;
        console.log('data', d)

        fusion.forEach(d => {
          for(let g = 0; g < gene.length; g++) {
            if(d.source_name === gene[g].label) {
              d['source_breakpoint'] = gene[g].len / 2
              d['size'] = gene[g].len
            }
            if(d.target_name === gene[g].label) {
              d['target_breakpoint'] = gene[g].len / 2
            }
          }
        })

        // sorting gene
        gene.map((d) => {
          d["num"] = d.chr.substr(3, 2);
          if(d.num === 'X') {
            d.num = Number(d.chr.substr(3, 2));
            d.num = 23;
          }
          if(d.num === 'Y') {
            d.num = Number(d.chr.substr(3, 2));
            d.num = 24
          }
          if(d.num === 'Un') {
            d.num = Number(d.chr.substr(3, 2));
            d.num = 25
          }
          if(d.num === 'Ot') {
            d.num = Number(d.chr.substr(3, 2));
            d.num = 26
          }
        });
        gene.sort(function(a, b) {
          return a.num - b.num
        });

        // draw circos chart
        const drawCircos = (gene, d) => {
          const width = 800;
          // create circos instance
          const circos = new Circos({
            container: '#circos',
            width: width,
            height: width
          });
          // define def for arrow representation
          const arrow = d3.select('svg').append('defs').append('marker')
            .attr('id', 'arrow')
            .attr('viewBox', '0 0 120 120')
            .attr('refX', 115)
            .attr('refY', 115)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M2,2 L10,6 L2,10 L6,6 L2,2')
            .style('fill', '#ff5722')
          // format fusion data
          d = d.map(function (d) {
            return {
              source: {
                id: d.source_name,
                start: parseInt(d.source_breakpoint) - parseInt(d.source_breakpoint),
                end: parseInt(d.source_breakpoint) + parseInt(d.source_breakpoint),
                name: d.source_name,
                chr: d.source_id
              },
              target: {
                id: d.target_name,
                start: parseInt(d.target_breakpoint) - parseInt(d.target_breakpoint),
                end: parseInt(d.target_breakpoint) + parseInt(d.target_breakpoint),
                name: d.target_name,
                chr: d.target_id
              }
            }
          });

          // config circos layout
          circos
            .layout(gene,
            {
              innerRadius: width/2 - 100,
              outerRadius: width/2 - 90,
              labels: {
                display: false,
                size: 10,
                color: '#181818',
                radialOffset: 40
              },
              ticks: {
                display: false,
                color: '#181818',
                labelSize: 10
              }
            })
            .chords('l1', d,
            {
              opacity: 0.7,
              color: '#ff5722',
              tooltipContent: function (d) {
                return '<h3>' + d.source.id + ' ➤ ' + d.target.id + '</h3>'
              },
            })
            .render()
          // end circos object
          const a = d3.selectAll('.chord')
            .style('marker-end', 'url(#arrow)')
        }
        // Call drawCircos
        drawCircos(gene, fusion);

        // New layout for change label location
        const width = 800;

        const makeAngle = (d) => {
          const k = ((d.end - d.start) / 2) / d.len ;
          const angle = d.len * k + d.start;
          return angle
        }
           
        const layout = d3.select('.cs-layout').selectAll('g').data(gene).join('g')
          .attr('class', d => d.label)
          .attr('opacity', '1')
        
        const g = layout.append('g')
          .attr('transform', d => `rotate(${makeAngle(d) * 180 / Math.PI - 90}) translate(330, 0)`)

        const text = g.append('text')
          .attr('dy', '.35em')
          .attr("transform", d => makeAngle(d) > Math.PI ? "rotate(180) translate(0)" : null)
          .attr("text-anchor", d => makeAngle(d) > Math.PI ? 'end' : null)
          .style('font-size', '11px')
          .text(d => d.label)
        // end circos
      })

    </script>
  </body>
</html>